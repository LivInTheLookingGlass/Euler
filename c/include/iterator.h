/**
 * @file iterator.h
 * @author Olivia Appleton
 * @date 15 Oct 2019
 * @brief An implementation of Python-like iterators and generators using macros to maintain static typing
 */
#ifndef ITERATOR_H
#define ITERATOR_H

#include <stdbool.h>
#include <stdint.h>
#include "macros.h"

#ifdef DOXYGEN
namespace c::include::iterator {
#endif

/**
 * @brief The base definition macro for all iterators in this project
 * @param return_type The type that your iterator will yield
 * @param struct_type The type that your iterator state is stored in
 * @relatedalso c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 * @remark
 * It is recommended that you put this at the end of your struct for better packing, but if
 * you are going to use bitfield elements, it should go before that.
 * @attention
 * When you are declaring an Iterator struct, you MUST DECLARE IT FIRST in order to feed it to this macro
 *
 * Example:
 * @code{.c}
 * typedef struct counter counter;
 * struct counter {
 *     uintmax_t idx;
 *     uintmax_t stop;
 *     intmax_t step;
 *     IteratorTail(uintmax_t, counter)
 * };
 * @endcode
 */
#define IteratorTail(return_type, struct_type) \
    return_type (*iterator_function)(struct_type *it); /**< @private The pointer to the iteration function @see next @cond EXPAND_ITERATOR_TAIL */\
    bool exhausted : 1;\
    bool started : 1;\
    bool phase : 1; /** @endcond */

/**
 * @brief The base macro for all iteration functions in this project
 * @param it The pointer to the iterator you are advancing
 * @relatedalso c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 *
 * Example:
 * @code{.c}
 * static uintmax_t iterate_counter(counter *ct) {
 *     IterationHead(ct);
 *     if (!ct->exhausted) {
 *         const uintmax_t ret = ct->idx;
 *         ct->idx += ct->step;
 *         ct->exhausted = (ct->idx >= ct->stop);
 *         return ret;
 *     }
 *     return -1;  // error
 * }
 * @endcode
 */
#define IterationHead(it) \
    it->started = 1; \
    it->phase = !(it->phase)

/**
 * @brief The base macro for all iterator initialization functions in this project
 * @param advance The function this iterator uses to advance
 * @returns A compound literal that initializes the @ref c::include::iterator::Iterator "Iterator-defined" portions of your subclass
 * @relatedalso c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 * @note
 * All values not directly related to the @ref c::include::iterator::Iterator "Iterator" class will be initialized according to the C99 rules
 * for compound literals. This means:
 * @li Numeric types are initialized to @c 0
 * @li Pointer types are initialized to @c NULL
 * @li Composite types are initialized recursively by these rules
 *
 * @attention
 * The iterator function you give it MUST take in ONLY a pointer to the declared struct
 *
 * Example:
 * @code{.c}
 * counter counter0() {
 *     counter ct = IteratorInitHead(iterate_counter);
 *     ct.step = 1;
 *     ct.stop = 100;
 *     return ct;  // note all other values are initialized to 0
 * }
 * @endcode
 */
#define IteratorInitHead(advance) {.iterator_function = &advance}

/**
 * @brief The macro to advance generic iterators
 * @param state The iterator you wish to advance
 * @returns The next item generated by the given iterator
 * @relatedalso c::include::iterator::Iterator
 * @see next_p
 * For a version that deals with pointers
 * @see counter
 * for an example implementation
 */
#define next(state) (*(state.iterator_function))(&state)

/**
 * @brief The macro to advance generic iterator pointers
 * @param state The pointer to the iterator you wish to advance
 * @returns The next item generated by the given iterator
 * @relatedalso c::include::iterator::Iterator
 * @see next
 * For a version that deals with direct objects
 * @see counter
 * for an example implementation
 */
#define next_p(state) (*(state->iterator_function))(state)

typedef struct Iterator Iterator;
/**
 * @brief An implementation of Python-like iterators and generators in C
 * @see counter
 * For an example implementation
 */
struct Iterator {
    bool exhausted : 1; /**< An indicator that the iterator has stopped */
    bool started : 1; /**< An indicator that the iterator has started */
    bool phase : 1; /**< An indicator that changes each time the iterator moves */
};

typedef struct counter counter;
/**
 * @brief The reference struct for all iterators in this project
 * @implements Iterator
 */
struct counter {
    uintmax_t idx; /**< The current position of the counter */
    uintmax_t stop; /**< The value before which the counter will stop */
    intmax_t step; /**< The amount by which the counter will move */
    IteratorTail(uintmax_t, counter)
};

/**
 * @private
 * @brief The function to advance a counter
 * @param i the counter you want to advance
 * @memberof counter
 *
 * @returns the next number in the iteration
 */
static uintmax_t iterate_counter(counter *i);
static inline uintmax_t iterate_counter(counter *i) {
    IterationHead(i);
    uintmax_t ret = i->idx;
    intmax_t step = i->step;
    i->idx += step;
    if ((step > 0 && i->idx >= i->stop) || (step < 0 && i->idx <= i->stop))   {
        i->exhausted = 1;
    }
    return ret;
}

/**
 * @brief The base constructor for the counter iterator
 * @param start The beginning position of the counter
 * @param stop The point where the counter is exhausted
 * @param step The amount to step by each time you iterate the counter
 * @memberof counter
 *
 * @returns A @ref counter
 */
counter counter3(uintmax_t start, uintmax_t stop, intmax_t step);
inline counter counter3(uintmax_t start, uintmax_t stop, intmax_t step) {
    counter ret = IteratorInitHead(iterate_counter);
    ret.idx = start;
    ret.stop = stop;
    ret.step = step;
    return ret;
}

/**
 * @brief The simpler constructor for the counter iterator
 * @param start The beginning position of the counter
 * @param stop The point where the counter is exhausted
 * @memberof counter
 *
 * @returns A @ref counter
 */
counter counter2(uintmax_t start, uintmax_t stop);
inline counter counter2(uintmax_t start, uintmax_t stop)  {
    return counter3(start, stop, 1);
}

/**
 * @brief The simplest constructor for the counter iterator
 * @param stop The point where the counter is exhausted
 * @memberof counter
 *
 * @returns A @ref counter
 */
counter counter1(uintmax_t stop);
inline counter counter1(uintmax_t stop)    {
    return counter2(0, stop);
}

#ifdef DOXYGEN
};
#endif

#endif
