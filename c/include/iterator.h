#ifndef ITERATOR_H
#define ITERATOR_H

#include <stdbool.h>
#include <stdint.h>
#include "macros.h"

#ifdef DOXYGEN
namespace c::include::iterator {
#endif

/**
 * @brief The base definition macro for all iterators in this project
 * @param return_type The type that your iterator will yield
 * @param struct_type The type that your iterator state is stored in
 * @memberof c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 * @remark
 * It is recommended that you put this at the end of your struct for better packing, but if
 * you are going to use bitfield elements, it should go before that.
 * @attention
 * When you are declaring an Iterator struct, you MUST DECLARE IT FIRST in order to feed it to this macro
 */
#define IteratorTail(return_type, struct_type) \
    return_type (*iterator_function)(struct_type *it); /**< @private The pointer to the iteration function @see next */\
    /** @cond EXPAND_ITERATOR_TAIL */ \
    bool exhausted : 1;\
    bool started : 1;\
    bool phase : 1; /** @endcond */

/**
 * @brief The base macro for all iteration functions in this project
 * @param it The pointer to the iterator you are advancing
 * @memberof c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 */
#define IterationHead(it) \
    it->started = 1; \
    it->phase = !(it->phase)

/**
 * @brief The base macro for all iterator initialization functions in this project
 * @param advance The function this iterator uses to advance
 * @memberof c::include::iterator::Iterator
 * @see counter
 * for an example implementation
 * @attention
 * The iterator function you give it MUST take in ONLY a pointer to the declared struct
 */
#define IteratorInitHead(advance) {.iterator_function = &advance}

/**
 * @brief The macro to advance generic iterators
 * @param state The iterator you wish to advance
 * @returns The next item generated by the given iterator
 * @memberof c::include::iterator::Iterator
 * @see next_p
 * For a version that deals with pointers
 * @see counter
 * for an example implementation
 */
#define next(state) (*(state.iterator_function))(&state)

/**
 * @brief The macro to advance generic iterator pointers
 * @param state The pointer to the iterator you wish to advance
 * @returns The next item generated by the given iterator
 * @memberof c::include::iterator::Iterator
 * @see next
 * For a version that deals with direct objects
 * @see counter
 * for an example implementation
 */
#define next_p(state) (*(state->iterator_function))(state)

typedef struct Iterator Iterator;
/**
 * @brief An implementation of Python-like iterators and generators in C
 * @see counter
 * For an example implementation
 */
struct Iterator {
    bool exhausted : 1; /**< An indicator that the iterator has stopped */
    bool started : 1; /**< An indicator that the iterator has started */
    bool phase : 1; /**< An indicator that changes each time the iterator moves */
};

typedef struct counter counter;
/**
 * @brief The reference struct for all iterators in this project
 * @implements Iterator
 */
struct counter {
    uintmax_t idx; /**< The current position of the counter */
    uintmax_t stop; /**< The value before which the counter will stop */
    intmax_t step; /**< The amount by which the counter will move */
    IteratorTail(uintmax_t, counter)
};

/**
 * @private
 * @brief The function to advance a counter
 * @param i the counter you want to advance
 * @relates counter
 *
 * @returns the next number in the iteration
 */
uintmax_t iterate_counter(counter *i);
inline uintmax_t iterate_counter(counter *i)    {
    IterationHead(i);
    uintmax_t ret = i->idx;
    intmax_t step = i->step;
    i->idx += step;
    if ((step > 0 && i->idx >= i->stop) || (step < 0 && i->idx <= i->stop))   {
        i->exhausted = 1;
    }
    return ret;
}

/**
 * @brief The base constructor for the counter iterator
 * @param start The beginning position of the counter
 * @param stop The point where the counter is exhausted
 * @param step The amount to step by each time you iterate the counter
 * @relates counter
 *
 * @returns A @ref counter
 */
counter counter3(uintmax_t start, uintmax_t stop, intmax_t step);
inline counter counter3(uintmax_t start, uintmax_t stop, intmax_t step) {
    counter ret = IteratorInitHead(iterate_counter);
    ret.idx = start;
    ret.stop = stop;
    ret.step = step;
    return ret;
}

/**
 * @brief The simpler constructor for the counter iterator
 * @param start The beginning position of the counter
 * @param stop The point where the counter is exhausted
 * @relates counter
 *
 * @returns A @ref counter
 */
counter counter2(uintmax_t start, uintmax_t stop);
inline counter counter2(uintmax_t start, uintmax_t stop)  {
    return counter3(start, stop, 1);
}

/**
 * @brief The simplest constructor for the counter iterator
 * @param stop The point where the counter is exhausted
 * @relates counter
 *
 * @returns A @ref counter
 */
counter counter1(uintmax_t stop);
inline counter counter1(uintmax_t stop)    {
    return counter2(0, stop);
}

#ifdef DOXYGEN
};
#endif

#endif
